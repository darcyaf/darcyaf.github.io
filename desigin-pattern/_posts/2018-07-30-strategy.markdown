---
title:  "Strategy Pattern"
subtitle: "策略模式"
author: "c.j"
avatar: "img/authors/wferr.png"
image: "img/f.jpg"
date:   "2018-07-30 03:45"
---

### Definition
定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

### Example 以做鸭子作为例子：
-  v1
{% highlight java %}
  public abstract class Duck {
    public void quack();
    public void swim();
    }
{% endhighlight %}
看起来很好，我们只用了一个抽象类就实现了鸭子的功能,但是，当我们需要拓展时就遇到了问题，
比如我要绿帽鸭会飞。此时就无法直接用抽象类来做，否则所有的鸭子都会有这个功能。
因此考虑到使用组合来实现。
-  v2
{% highlight java %}
   public class GreenHatDuck implements Flyable,Quackable{
     }
{% endhighlight %}
看起来确实满足了我们的要求，我们可以实现这个接口，就可以实现全自定义。
但是啊，未免工作量也太大了吧，每增加一个接口就需要一段复制粘贴
- v3 
每个行为都由超类来做定义，然后在进行实现，每个Duck在初始化的时候实现对应的具体类
{% highlight java %}
public interface FlyBehavior{
  public function fly()
{% endhighlight %}
